create table public.albums (
  id serial not null,
  title text not null,
  artist text not null,
  release_year integer null,
  release_date date null,
  genres text[] null,
  label text null,
  country text null,
  cover_image_url text null,
  catno text null,
  barcode text null,
  status text null default 'want_to_listen'::text,
  notes text null,
  user_id uuid null default auth.uid (),
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  listened_date date null,
  spotify_id text null,
  album_type text null,
  total_tracks integer null,
  spotify_uri text null,
  spotify_href text null,
  favorited boolean not null default false,
  constraint albums_pkey primary key (id)
) TABLESPACE pg_default;

create index IF not exists idx_albums_title on public.albums using btree (title) TABLESPACE pg_default;

create index IF not exists idx_albums_artist on public.albums using btree (artist) TABLESPACE pg_default;

create index IF not exists idx_albums_status on public.albums using btree (status) TABLESPACE pg_default;

create index IF not exists idx_albums_user_id on public.albums using btree (user_id) TABLESPACE pg_default;

create index IF not exists idx_albums_title_lower on public.albums using btree (lower(title)) TABLESPACE pg_default;

create index IF not exists idx_albums_artist_lower on public.albums using btree (lower(artist)) TABLESPACE pg_default;

create index IF not exists idx_albums_created_at on public.albums using btree (created_at) TABLESPACE pg_default;

create index IF not exists idx_albums_release_year on public.albums using btree (release_year) TABLESPACE pg_default
where
  (release_year is not null);

create index IF not exists idx_albums_spotify_id on public.albums using btree (spotify_id) TABLESPACE pg_default;

create index IF not exists idx_albums_favorited on public.albums using btree (favorited) TABLESPACE pg_default;

create trigger set_album_user_id_trigger BEFORE INSERT on albums for EACH row
execute FUNCTION set_album_user_id ();

create trigger set_user_id_for_albums_trigger BEFORE INSERT on albums for EACH row
execute FUNCTION set_user_id_for_albums ();

create table public.diary (
  id serial not null,
  title text not null,
  rating numeric null,
  watched_date date null,
  rewatch text null,
  tags text null,
  release_date date null,
  release_year numeric null,
  runtime integer null,
  director text null,
  poster_url text null,
  genres text[] null,
  ratings100 numeric null,
  tmdb_id integer null,
  overview text null,
  backdrop_path text null,
  vote_average numeric(3, 1) null,
  vote_count integer null,
  popularity numeric(8, 3) null,
  original_language character varying(10) null,
  original_title text null,
  tagline text null,
  status character varying(50) null,
  budget bigint null,
  revenue bigint null,
  imdb_id character varying(20) null,
  homepage text null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  reviews text null,
  favorited boolean not null default false,
  constraint movies_lb_pkey primary key (id)
) TABLESPACE pg_default;

create index IF not exists idx_diary_tmdb_id on public.diary using btree (tmdb_id) TABLESPACE pg_default;

create index IF not exists idx_diary_title on public.diary using btree (title) TABLESPACE pg_default;

create index IF not exists idx_diary_watched_date on public.diary using btree (watched_date) TABLESPACE pg_default;

create index IF not exists idx_diary_rating on public.diary using btree (rating) TABLESPACE pg_default;

create index IF not exists idx_diary_title_lower on public.diary using btree (lower(title)) TABLESPACE pg_default;

create index IF not exists idx_diary_director on public.diary using btree (director) TABLESPACE pg_default
where
  (director is not null);

create index IF not exists idx_diary_release_year on public.diary using btree (release_year) TABLESPACE pg_default
where
  (release_year is not null);

create index IF not exists idx_diary_runtime on public.diary using btree (runtime) TABLESPACE pg_default
where
  (runtime is not null);

create index IF not exists idx_diary_rewatch on public.diary using btree (rewatch) TABLESPACE pg_default;

create index IF not exists idx_diary_favorited on public.diary using btree (favorited) TABLESPACE pg_default;

create trigger sync_film_favorites_trigger
after
update OF favorited on diary for EACH row
execute FUNCTION sync_film_favorites ();

create table public.list_items (
  id bigint generated by default as identity not null,
  list_id uuid not null,
  tmdb_id integer not null,
  movie_title text not null,
  movie_poster_url text null,
  movie_year integer null,
  added_at timestamp with time zone not null default timezone ('utc'::text, now()),
  sort_order integer not null default 0,
  movie_backdrop_path text null,
  movie_release_date date null,
  constraint list_items_pkey primary key (id),
  constraint list_items_list_id_tmdb_id_key unique (list_id, tmdb_id),
  constraint list_items_list_id_fkey foreign KEY (list_id) references lists (id) on delete CASCADE,
  constraint list_items_movie_title_check check ((char_length(movie_title) > 0)),
  constraint list_items_movie_year_check check (
    (
      (movie_year > 1800)
      and (movie_year < 2100)
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_list_items_movie_release_date on public.list_items using btree (movie_release_date) TABLESPACE pg_default;

create index IF not exists idx_list_items_list_id on public.list_items using btree (list_id) TABLESPACE pg_default;

create index IF not exists idx_list_items_tmdb_id on public.list_items using btree (tmdb_id) TABLESPACE pg_default;

create index IF not exists idx_list_items_sort_order on public.list_items using btree (list_id, sort_order) TABLESPACE pg_default;

create index IF not exists idx_list_items_movie_title on public.list_items using btree (movie_title) TABLESPACE pg_default;

create table public.lists (
  id uuid not null default gen_random_uuid (),
  user_id uuid not null,
  name text not null,
  description text null,
  created_at timestamp with time zone not null default timezone ('utc'::text, now()),
  updated_at timestamp with time zone not null default timezone ('utc'::text, now()),
  pinned boolean null default false,
  ranked boolean not null default false,
  tags text null,
  themed_month_date date null,
  constraint lists_pkey primary key (id),
  constraint lists_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE,
  constraint check_valid_tags check (validate_list_tags (tags)),
  constraint check_valid_themed_month_date check (validate_themed_month_date (themed_month_date)),
  constraint lists_description_check check ((char_length(description) <= 500)),
  constraint lists_name_check check (
    (
      (char_length(name) > 0)
      and (char_length(name) <= 100)
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_lists_user_id on public.lists using btree (user_id) TABLESPACE pg_default;

create index IF not exists idx_lists_created_at on public.lists using btree (created_at desc) TABLESPACE pg_default;

create index IF not exists idx_lists_name on public.lists using btree (name) TABLESPACE pg_default;

create index IF not exists idx_lists_tags on public.lists using btree (tags) TABLESPACE pg_default;

create index IF not exists idx_lists_themed_month_date on public.lists using btree (themed_month_date) TABLESPACE pg_default;

create trigger update_lists_updated_at BEFORE
update on lists for EACH row
execute FUNCTION update_updated_at_column ();

create table public.month_descriptors (
  id bigint generated by default as identity not null,
  user_id uuid not null,
  month_year text not null,
  descriptor text not null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint month_descriptors_pkey primary key (id),
  constraint unique_user_month_year unique (user_id, month_year),
  constraint month_descriptors_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_month_descriptors_user_month on public.month_descriptors using btree (user_id, month_year) TABLESPACE pg_default;

create trigger update_month_descriptors_updated_at_trigger BEFORE
update on month_descriptors for EACH row
execute FUNCTION update_month_descriptors_updated_at ();

create table public.users (
  id uuid not null default gen_random_uuid (),
  google_id text not null,
  email text not null,
  name text not null,
  picture text null,
  created_at timestamp with time zone null default now(),
  last_login timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  selected_backdrop_movie_id integer null,
  constraint users_pkey primary key (id),
  constraint users_email_key unique (email),
  constraint users_google_id_key unique (google_id),
  constraint users_selected_backdrop_movie_id_fkey foreign KEY (selected_backdrop_movie_id) references diary (id) on delete set null
) TABLESPACE pg_default;

create index IF not exists idx_users_email on public.users using btree (email) TABLESPACE pg_default;

create index IF not exists idx_users_google_id on public.users using btree (google_id) TABLESPACE pg_default;

create index IF not exists idx_users_backdrop_movie on public.users using btree (selected_backdrop_movie_id) TABLESPACE pg_default;

create trigger update_users_updated_at BEFORE
update on users for EACH row
execute FUNCTION update_updated_at_column ();

create table public.watchlist (
  id bigserial not null,
  user_id uuid not null,
  tmdb_id integer not null,
  movie_title text not null,
  movie_poster_url text null,
  movie_backdrop_path text null,
  movie_year integer null,
  movie_release_date text null,
  added_at timestamp with time zone not null default now(),
  constraint watchlist_pkey1 primary key (id),
  constraint watchlist_user_id_tmdb_id_key unique (user_id, tmdb_id),
  constraint watchlist_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_watchlist_user_id on public.watchlist using btree (user_id) TABLESPACE pg_default;

create index IF not exists idx_watchlist_tmdb_id on public.watchlist using btree (tmdb_id) TABLESPACE pg_default;