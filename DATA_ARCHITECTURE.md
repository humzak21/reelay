# Reelay2 - Data Architecture & Backend Documentation

> **ğŸ“„ Complete SQL Schema:** See [`reelay_schema_list.sql`](./reelay_schema_list.sql) for the full production database schema with all tables, indexes, triggers, and constraints.

## Table of Contents
1. [System Overview](#system-overview)
2. [Data Storage Architecture](#data-storage-architecture)
3. [Core Data Models](#core-data-models)
4. [Database Schema](#database-schema)
5. [Service Layer Architecture](#service-layer-architecture)
6. [API Layer](#api-layer)
7. [Caching Strategy](#caching-strategy)
8. [External Integrations](#external-integrations)
9. [Authentication & Security](#authentication--security)
10. [Data Flow & Processing](#data-flow--processing)

---

## System Overview

Reelay2 is a media tracking application built on a **three-tier architecture**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  iOS Client (Swift) â”‚
â”‚    SwiftUI + Swift  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Service Layer     â”‚
â”‚  (Supabase Client)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Backend Stack     â”‚
â”‚ Supabase PostgreSQL â”‚
â”‚   Node.js/Express   â”‚
â”‚      Redis Cache    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Technology Stack

**Frontend:**
- SwiftUI (iOS 26.0+)
- Swift 5.0+
- SwiftData for local persistence

**Backend:**
- **Primary Database:** Supabase (PostgreSQL 15+)
- **Caching Layer:** Redis
- **API Server:** Node.js + Express (server.js)
- **Row-Level Security:** Supabase RLS policies

**External APIs:**
- TMDB API (The Movie Database) - Movie/TV metadata
- Spotify Web API - Album metadata
- Streaming Availability API (RapidAPI) - Streaming service data

---

## Data Storage Architecture

### 1. Dual Storage System

Reelay2 employs a **hybrid storage strategy**:

#### A. Cloud Storage (Supabase PostgreSQL)
- **Primary source of truth** for user data
- Real-time synchronization
- Multi-device support
- Row-Level Security (RLS) enabled

#### B. Local Storage (SwiftData)
- **Offline-first** caching mechanism
- Uses SwiftData for persistent local storage
- Models: `PersistentMovieList`, `PersistentListItem`
- Synchronized with cloud data on app launch and after mutations

### 2. Database Tables

The PostgreSQL database contains the following core tables:

| Table Name | Purpose | Row Count Est. | Key Relationships |
|------------|---------|----------------|-------------------|
| `diary` | Movie watch entries | 1000s | User's movie viewing history |
| `albums` | Music album tracking | 100s | User's album listening list |
| `television` | TV show progress | 100s | User's TV watching status |
| `lists` | Custom movie lists | 10s-100s | Parent to list_items |
| `list_items` | Items in lists | 1000s | Child of lists, references TMDB IDs |
| `watchlist` | Movies to watch | 100s | User's watchlist |
| `album_tracks` | Album track listings | 1000s | Child of albums |
| `users` | User profiles | 1 per user | Google OAuth integration |
| `month_descriptors` | Monthly themes | 12 per year | For "Themed Months" feature |

**Production Schema Statistics:**
- **7 Core Tables** (diary, albums, television, lists, list_items, watchlist, users)
- **2 Supporting Tables** (album_tracks, month_descriptors)
- **26 Performance Indexes** across all tables
- **7 Database Triggers** for auto-updates and data integrity
- **12 Constraints** (CHECK, UNIQUE, FOREIGN KEY)
- **3 Validation Functions** (validate_list_tags, validate_themed_month_date, sync_film_favorites)

**Key Schema Features:**
- All user-owned tables use `user_id UUID` with CASCADE deletion
- Timestamps use `TIMESTAMP WITH TIME ZONE` for global consistency
- Array fields use PostgreSQL native `TEXT[]` type
- Partial indexes on nullable columns (e.g., `WHERE director IS NOT NULL`)
- Unique constraints prevent duplicates (e.g., `user_id + tmdb_id` in watchlist)
- Auto-increment using `SERIAL`, `BIGSERIAL`, or `GENERATED BY DEFAULT AS IDENTITY`

---

## Core Data Models

### 1. Movie (Diary Entry)

**Purpose:** Represents a single movie viewing event in the user's diary.

**Swift Model:** `Movie` (in `Movie.swift`)

**Key Fields:**

```swift
struct Movie: Codable, Identifiable {
    // Primary Identifier
    let id: Int                          // Auto-incrementing serial ID
    
    // Core Movie Data
    let title: String                    // Movie title
    let release_year: Int?               // Year of release
    let release_date: String?            // Full release date (yyyy-MM-dd)
    let tmdb_id: Int?                    // TMDB external ID (can watch same movie multiple times)
    
    // User Interaction Data
    let rating: Double?                  // Star rating (0-5)
    let detailed_rating: Double?         // Detailed rating (0-100) [maps to ratings100 in DB]
    let review: String?                  // User's written review [maps to reviews in DB]
    let tags: String?                    // Comma-separated tags (IMAX, Theater, Family, etc.)
    let watch_date: String?              // When user watched (yyyy-MM-dd) [maps to watched_date]
    let is_rewatch: Bool?                // Is this a rewatch? [maps to rewatch string: "yes"/"no"]
    let favorited: Bool?                 // Favorite flag
    
    // TMDB Metadata
    let overview: String?                // Movie description/plot
    let poster_url: String?              // Poster image URL (TMDB path or full URL)
    let backdrop_path: String?           // Backdrop image URL
    let director: String?                // Director name
    let runtime: Int?                    // Runtime in minutes
    let vote_average: Double?            // TMDB community rating
    let vote_count: Int?                 // TMDB vote count
    let popularity: Double?              // TMDB popularity score
    let original_language: String?       // Original language code
    let original_title: String?          // Original title
    let tagline: String?                 // Movie tagline
    let status: String?                  // Production status
    let budget: Int?                     // Production budget
    let revenue: Int?                    // Box office revenue
    let imdb_id: String?                 // IMDb ID
    let homepage: String?                // Official homepage
    let genres: [String]?                // Array of genre names
    
    // Timestamps
    let created_at: String?              // When added to diary
    let updated_at: String?              // Last modification
}
```

**Database Schema (`diary` table):**

```sql
-- Complete Production Schema
CREATE TABLE public.diary (
  id SERIAL NOT NULL,
  title TEXT NOT NULL,
  rating NUMERIC NULL,
  watched_date DATE NULL,
  rewatch TEXT NULL,                     -- "yes" or "no" as text
  tags TEXT NULL,
  release_date DATE NULL,
  release_year NUMERIC NULL,
  runtime INTEGER NULL,
  director TEXT NULL,
  poster_url TEXT NULL,
  genres TEXT[] NULL,                    -- PostgreSQL array type
  ratings100 NUMERIC NULL,
  tmdb_id INTEGER NULL,
  overview TEXT NULL,
  backdrop_path TEXT NULL,
  vote_average NUMERIC(3, 1) NULL,
  vote_count INTEGER NULL,
  popularity NUMERIC(8, 3) NULL,
  original_language VARCHAR(10) NULL,
  original_title TEXT NULL,
  tagline TEXT NULL,
  status VARCHAR(50) NULL,
  budget BIGINT NULL,
  revenue BIGINT NULL,
  imdb_id VARCHAR(20) NULL,
  homepage TEXT NULL,
  created_at TIMESTAMP WITH TIME ZONE NULL DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE NULL DEFAULT NOW(),
  reviews TEXT NULL,
  favorited BOOLEAN NOT NULL DEFAULT FALSE,
  CONSTRAINT movies_lb_pkey PRIMARY KEY (id)
) TABLESPACE pg_default;

-- Performance Indexes (10 total)
CREATE INDEX IF NOT EXISTS idx_diary_tmdb_id ON public.diary USING btree (tmdb_id);
CREATE INDEX IF NOT EXISTS idx_diary_title ON public.diary USING btree (title);
CREATE INDEX IF NOT EXISTS idx_diary_watched_date ON public.diary USING btree (watched_date);
CREATE INDEX IF NOT EXISTS idx_diary_rating ON public.diary USING btree (rating);
CREATE INDEX IF NOT EXISTS idx_diary_title_lower ON public.diary USING btree (LOWER(title));
CREATE INDEX IF NOT EXISTS idx_diary_director ON public.diary USING btree (director) 
  WHERE (director IS NOT NULL);
CREATE INDEX IF NOT EXISTS idx_diary_release_year ON public.diary USING btree (release_year) 
  WHERE (release_year IS NOT NULL);
CREATE INDEX IF NOT EXISTS idx_diary_runtime ON public.diary USING btree (runtime) 
  WHERE (runtime IS NOT NULL);
CREATE INDEX IF NOT EXISTS idx_diary_rewatch ON public.diary USING btree (rewatch);
CREATE INDEX IF NOT EXISTS idx_diary_favorited ON public.diary USING btree (favorited);

-- Triggers
CREATE TRIGGER sync_film_favorites_trigger
  AFTER UPDATE OF favorited ON diary
  FOR EACH ROW
  EXECUTE FUNCTION sync_film_favorites();
```

**Data Type Mappings:**

| Swift Property | Database Column | Type Transformation |
|---------------|----------------|---------------------|
| `detailed_rating` | `ratings100` | Direct mapping, field name differs |
| `review` | `reviews` | Direct mapping, field name differs |
| `watch_date` | `watched_date` | Direct mapping, field name differs |
| `is_rewatch` | `rewatch` | Bool â†” String ("yes"/"no") |
| `genres` | `genres` | Array â†” PostgreSQL TEXT[] |

### 2. Album

**Purpose:** Tracks music albums the user wants to listen to or has listened to.

**Swift Model:** `Album` (in `Album.swift`)

**Key Fields:**

```swift
struct Album: Codable, Identifiable {
    // Primary Identifier
    let id: Int
    
    // Core Album Data
    let title: String
    let artist: String
    let release_year: Int?
    let release_date: String?
    
    // Metadata
    let genres: [String]?                // Music genres
    let label: String?                   // Record label
    let country: String?                 // Release country
    let album_type: String?              // Album, EP, Single
    let total_tracks: Int?               // Track count
    
    // Spotify Integration
    let spotify_id: String?              // Spotify album ID
    let spotify_uri: String?             // spotify:album:xxx
    let spotify_href: String?            // API href
    let cover_image_url: String?         // Album art URL
    
    // Physical Media Data (from Discogs originally, now optional)
    let catno: String?                   // Catalog number
    let barcode: String?
    
    // User Status
    let status: String                   // want_to_listen, listened, removed
    let notes: String?
    let listened_date: String?           // When marked as listened
    let favorited: Bool?
    
    // System Fields
    let user_id: String?
    let created_at: String
    let updated_at: String
    
    // Related Data
    let tracks: [Track]?                 // Embedded track listings
}
```

**Database Schema (`albums` table):**

```sql
-- Complete Production Schema
CREATE TABLE public.albums (
  id SERIAL NOT NULL,
  title TEXT NOT NULL,
  artist TEXT NOT NULL,
  release_year INTEGER NULL,
  release_date DATE NULL,
  genres TEXT[] NULL,
  label TEXT NULL,
  country TEXT NULL,
  cover_image_url TEXT NULL,
  catno TEXT NULL,                       -- Catalog number
  barcode TEXT NULL,
  status TEXT NULL DEFAULT 'want_to_listen'::text,
  notes TEXT NULL,
  user_id UUID NULL DEFAULT auth.uid(),
  created_at TIMESTAMP WITH TIME ZONE NULL DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE NULL DEFAULT NOW(),
  listened_date DATE NULL,
  spotify_id TEXT NULL,
  album_type TEXT NULL,
  total_tracks INTEGER NULL,
  spotify_uri TEXT NULL,
  spotify_href TEXT NULL,
  favorited BOOLEAN NOT NULL DEFAULT FALSE,
  CONSTRAINT albums_pkey PRIMARY KEY (id)
) TABLESPACE pg_default;

-- Performance Indexes (11 total)
CREATE INDEX IF NOT EXISTS idx_albums_title ON public.albums USING btree (title);
CREATE INDEX IF NOT EXISTS idx_albums_artist ON public.albums USING btree (artist);
CREATE INDEX IF NOT EXISTS idx_albums_status ON public.albums USING btree (status);
CREATE INDEX IF NOT EXISTS idx_albums_user_id ON public.albums USING btree (user_id);
CREATE INDEX IF NOT EXISTS idx_albums_title_lower ON public.albums USING btree (LOWER(title));
CREATE INDEX IF NOT EXISTS idx_albums_artist_lower ON public.albums USING btree (LOWER(artist));
CREATE INDEX IF NOT EXISTS idx_albums_created_at ON public.albums USING btree (created_at);
CREATE INDEX IF NOT EXISTS idx_albums_release_year ON public.albums USING btree (release_year)
  WHERE (release_year IS NOT NULL);
CREATE INDEX IF NOT EXISTS idx_albums_spotify_id ON public.albums USING btree (spotify_id);
CREATE INDEX IF NOT EXISTS idx_albums_favorited ON public.albums USING btree (favorited);

-- Triggers for auto-setting user_id
CREATE TRIGGER set_album_user_id_trigger 
  BEFORE INSERT ON albums 
  FOR EACH ROW
  EXECUTE FUNCTION set_album_user_id();

CREATE TRIGGER set_user_id_for_albums_trigger 
  BEFORE INSERT ON albums 
  FOR EACH ROW
  EXECUTE FUNCTION set_user_id_for_albums();
```

### 3. Television

**Purpose:** Tracks TV show watching progress and metadata.

**Swift Model:** `Television` (in `Television.swift`)

**Key Fields:**

```swift
struct Television: Codable, Identifiable {
    let id: Int
    let name: String
    
    // Air Dates
    let first_air_year: Int?
    let first_air_date: String?
    let last_air_date: String?
    
    // User Ratings & Reviews
    let rating: Double?                  // Star rating (0-5)
    let detailed_rating: Double?         // Detailed rating (0-100)
    let review: String?
    let tags: String?
    
    // Progress Tracking
    let current_season: Int?             // Currently watching season
    let current_episode: Int?            // Currently watching episode
    let total_seasons: Int?
    let total_episodes: Int?
    let status: String?                  // watching, completed, dropped, plan_to_watch
    
    // TMDB Metadata
    let tmdb_id: Int?
    let overview: String?
    let poster_url: String?
    let backdrop_path: String?
    let vote_average: Double?
    let vote_count: Int?
    let popularity: Double?
    let original_language: String?
    let original_name: String?
    let tagline: String?
    let series_status: String?           // Ended, Returning Series, etc.
    let homepage: String?
    let genres: [String]?
    let networks: [String]?              // Broadcasting networks
    let created_by: [String]?            // Show creators
    let episode_run_time: [Int]?         // Typical episode lengths
    let in_production: Bool?
    let number_of_episodes: Int?
    let number_of_seasons: Int?
    let origin_country: [String]?
    let type: String?                    // Scripted, Reality, etc.
    
    // Current Episode Detail (for tracking exact position)
    let current_episode_name: String?
    let current_episode_overview: String?
    let current_episode_air_date: String?
    let current_episode_still_path: String?
    let current_episode_runtime: Int?
    let current_episode_vote_average: Double?
    
    // System
    let created_at: String?
    let updated_at: String?
    let favorited: Bool?
}
```

**Status Enum:**

```swift
enum WatchingStatus: String {
    case watching = "watching"
    case completed = "completed"
    case waiting = "waiting"              // Between seasons
    case planToWatch = "plan_to_watch"
}
```

### 4. Lists & List Items

**Purpose:** Custom movie collections with ranking support.

**Swift Models:**

```swift
struct MovieList: Codable, Identifiable {
    let id: UUID                         // Uses UUID for lists
    let userId: UUID
    let name: String
    let description: String?
    let createdAt: Date
    let updatedAt: Date
    let itemCount: Int                   // Cached count
    let pinned: Bool                     // Pin to top
    let ranked: Bool                     // Enable drag-to-rank
    let tags: String?                    // Comma-separated tags
    let themedMonthDate: Date?           // Optional theme for a specific month
}

struct ListItem: Codable, Identifiable {
    let id: Int64                        // Serial ID
    let listId: UUID                     // FK to lists
    let tmdbId: Int                      // Movie reference (not FK - can add before watching)
    let movieTitle: String
    let moviePosterUrl: String?
    let movieBackdropPath: String?
    let movieYear: Int?
    let movieReleaseDate: String?
    let addedAt: Date
    let sortOrder: Int                   // For ranking/ordering (0-based)
}
```

**Database Schemas:**

```sql
-- LISTS TABLE - Complete Production Schema
CREATE TABLE public.lists (
  id UUID NOT NULL DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  name TEXT NOT NULL,
  description TEXT NULL,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT TIMEZONE('utc', NOW()),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT TIMEZONE('utc', NOW()),
  pinned BOOLEAN NULL DEFAULT FALSE,
  ranked BOOLEAN NOT NULL DEFAULT FALSE,
  tags TEXT NULL,
  themed_month_date DATE NULL,
  CONSTRAINT lists_pkey PRIMARY KEY (id),
  CONSTRAINT lists_user_id_fkey FOREIGN KEY (user_id) 
    REFERENCES auth.users(id) ON DELETE CASCADE,
  CONSTRAINT check_valid_tags CHECK (validate_list_tags(tags)),
  CONSTRAINT check_valid_themed_month_date CHECK (validate_themed_month_date(themed_month_date)),
  CONSTRAINT lists_description_check CHECK (CHAR_LENGTH(description) <= 500),
  CONSTRAINT lists_name_check CHECK (
    CHAR_LENGTH(name) > 0 AND CHAR_LENGTH(name) <= 100
  )
) TABLESPACE pg_default;

-- Indexes
CREATE INDEX IF NOT EXISTS idx_lists_user_id ON public.lists USING btree (user_id);
CREATE INDEX IF NOT EXISTS idx_lists_created_at ON public.lists USING btree (created_at DESC);
CREATE INDEX IF NOT EXISTS idx_lists_name ON public.lists USING btree (name);
CREATE INDEX IF NOT EXISTS idx_lists_tags ON public.lists USING btree (tags);
CREATE INDEX IF NOT EXISTS idx_lists_themed_month_date ON public.lists USING btree (themed_month_date);

-- Triggers
CREATE TRIGGER update_lists_updated_at 
  BEFORE UPDATE ON lists 
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- LIST_ITEMS TABLE - Complete Production Schema
CREATE TABLE public.list_items (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  list_id UUID NOT NULL,
  tmdb_id INTEGER NOT NULL,
  movie_title TEXT NOT NULL,
  movie_poster_url TEXT NULL,
  movie_year INTEGER NULL,
  added_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT TIMEZONE('utc', NOW()),
  sort_order INTEGER NOT NULL DEFAULT 0,
  movie_backdrop_path TEXT NULL,
  movie_release_date DATE NULL,
  CONSTRAINT list_items_pkey PRIMARY KEY (id),
  CONSTRAINT list_items_list_id_tmdb_id_key UNIQUE (list_id, tmdb_id),
  CONSTRAINT list_items_list_id_fkey FOREIGN KEY (list_id) 
    REFERENCES lists(id) ON DELETE CASCADE,
  CONSTRAINT list_items_movie_title_check CHECK (CHAR_LENGTH(movie_title) > 0),
  CONSTRAINT list_items_movie_year_check CHECK (
    movie_year > 1800 AND movie_year < 2100
  )
) TABLESPACE pg_default;

-- Indexes
CREATE INDEX IF NOT EXISTS idx_list_items_movie_release_date 
  ON public.list_items USING btree (movie_release_date);
CREATE INDEX IF NOT EXISTS idx_list_items_list_id 
  ON public.list_items USING btree (list_id);
CREATE INDEX IF NOT EXISTS idx_list_items_tmdb_id 
  ON public.list_items USING btree (tmdb_id);
CREATE INDEX IF NOT EXISTS idx_list_items_sort_order 
  ON public.list_items USING btree (list_id, sort_order);
CREATE INDEX IF NOT EXISTS idx_list_items_movie_title 
  ON public.list_items USING btree (movie_title);
```

**Special List: Watchlist**

The watchlist is implemented as a **synthetic list**, not stored in the `lists` table. It has:
- Fixed UUID: `00000000-0000-0000-0000-000000000001`
- Separate table: `watchlist`
- Similar structure to `list_items` but with `user_id` instead of `list_id`

### 5. Tracks (Album Track Listings)

**Purpose:** Individual tracks within an album.

```swift
struct Track: Codable, Identifiable {
    let id: Int
    let album_id: Int                    // FK to albums
    let track_number: Int                // Position in album (1-based)
    let title: String
    let artist: String?                  // Can differ from album artist
    let featured_artists: [String]?      // Featured artists
    let duration_ms: Int?                // Duration in milliseconds
    let spotify_id: String?
    let spotify_uri: String?
    let spotify_href: String?
    let created_at: String
    let updated_at: String
}
```

### 6. User Profile

**Purpose:** Extended user data beyond authentication.

```swift
struct UserProfile: Codable, Identifiable {
    let id: String                       // UUID from auth.users
    let google_id: String                // Google OAuth ID
    let email: String
    let name: String
    let picture: String?                 // Profile picture from Google
    let selected_backdrop_movie_id: Int? // For profile backdrop customization
    let created_at: String?
    let last_login: String?
    let updated_at: String?
}
```

**Database Schema:**

```sql
-- USERS TABLE - Complete Production Schema
CREATE TABLE public.users (
  id UUID NOT NULL DEFAULT gen_random_uuid(),
  google_id TEXT NOT NULL,
  email TEXT NOT NULL,
  name TEXT NOT NULL,
  picture TEXT NULL,
  created_at TIMESTAMP WITH TIME ZONE NULL DEFAULT NOW(),
  last_login TIMESTAMP WITH TIME ZONE NULL DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE NULL DEFAULT NOW(),
  selected_backdrop_movie_id INTEGER NULL,
  CONSTRAINT users_pkey PRIMARY KEY (id),
  CONSTRAINT users_email_key UNIQUE (email),
  CONSTRAINT users_google_id_key UNIQUE (google_id),
  CONSTRAINT users_selected_backdrop_movie_id_fkey FOREIGN KEY (selected_backdrop_movie_id) 
    REFERENCES diary(id) ON DELETE SET NULL
) TABLESPACE pg_default;

-- Indexes
CREATE INDEX IF NOT EXISTS idx_users_email ON public.users USING btree (email);
CREATE INDEX IF NOT EXISTS idx_users_google_id ON public.users USING btree (google_id);
CREATE INDEX IF NOT EXISTS idx_users_backdrop_movie ON public.users USING btree (selected_backdrop_movie_id);

-- Triggers
CREATE TRIGGER update_users_updated_at 
  BEFORE UPDATE ON users 
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- WATCHLIST TABLE - Complete Production Schema
CREATE TABLE public.watchlist (
  id BIGSERIAL NOT NULL,
  user_id UUID NOT NULL,
  tmdb_id INTEGER NOT NULL,
  movie_title TEXT NOT NULL,
  movie_poster_url TEXT NULL,
  movie_backdrop_path TEXT NULL,
  movie_year INTEGER NULL,
  movie_release_date TEXT NULL,
  added_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  CONSTRAINT watchlist_pkey1 PRIMARY KEY (id),
  CONSTRAINT watchlist_user_id_tmdb_id_key UNIQUE (user_id, tmdb_id),
  CONSTRAINT watchlist_user_id_fkey FOREIGN KEY (user_id) 
    REFERENCES auth.users(id) ON DELETE CASCADE
) TABLESPACE pg_default;

-- Indexes
CREATE INDEX IF NOT EXISTS idx_watchlist_user_id ON public.watchlist USING btree (user_id);
CREATE INDEX IF NOT EXISTS idx_watchlist_tmdb_id ON public.watchlist USING btree (tmdb_id);

-- MONTH_DESCRIPTORS TABLE - Complete Production Schema
-- For themed month feature (e.g., "Horror October")
CREATE TABLE public.month_descriptors (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  user_id UUID NOT NULL,
  month_year TEXT NOT NULL,
  descriptor TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE NULL DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE NULL DEFAULT NOW(),
  CONSTRAINT month_descriptors_pkey PRIMARY KEY (id),
  CONSTRAINT unique_user_month_year UNIQUE (user_id, month_year),
  CONSTRAINT month_descriptors_user_id_fkey FOREIGN KEY (user_id) 
    REFERENCES auth.users(id) ON DELETE CASCADE
) TABLESPACE pg_default;

-- Indexes
CREATE INDEX IF NOT EXISTS idx_month_descriptors_user_month 
  ON public.month_descriptors USING btree (user_id, month_year);

-- Triggers
CREATE TRIGGER update_month_descriptors_updated_at_trigger 
  BEFORE UPDATE ON month_descriptors 
  FOR EACH ROW
  EXECUTE FUNCTION update_month_descriptors_updated_at();
```

---

## Database Schema

### Entity Relationship Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ auth.users  â”‚ (Supabase Auth)
â”‚  - id (PK)  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚                                     â”‚
       â–¼                                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   users     â”‚                      â”‚   lists     â”‚
â”‚  - id (FK)  â”‚                      â”‚  - id (PK)  â”‚
â”‚  - google_idâ”‚                      â”‚  - user_id  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚  - ranked   â”‚
                                     â”‚  - pinned   â”‚
                                     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                                            â”‚
                                            â–¼
                                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                     â”‚ list_items  â”‚
                                     â”‚  - id (PK)  â”‚
                                     â”‚  - list_id  â”‚
                                     â”‚  - tmdb_id  â”‚
                                     â”‚  - sort_orderâ”‚
                                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   diary     â”‚         â”‚   albums    â”‚         â”‚ television  â”‚
â”‚  - id (PK)  â”‚         â”‚  - id (PK)  â”‚         â”‚  - id (PK)  â”‚
â”‚  - tmdb_id  â”‚         â”‚  - user_id  â”‚         â”‚  - tmdb_id  â”‚
â”‚  - favoritedâ”‚         â”‚  - status   â”‚         â”‚  - status   â”‚
â”‚  - tags     â”‚         â”‚  - spotify_idâ”‚        â”‚  - current_*â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                               â–¼
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚album_tracks â”‚
                        â”‚  - id (PK)  â”‚
                        â”‚  - album_id â”‚
                        â”‚  - track_#  â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  watchlist  â”‚ (Separate from lists)
â”‚  - id (PK)  â”‚
â”‚  - user_id  â”‚
â”‚  - tmdb_id  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Data Type Standards

**Dates:**
- Database: `DATE` or `TIMESTAMP WITH TIME ZONE`
- API/JSON: ISO-8601 strings (`"yyyy-MM-dd"` or `"yyyy-MM-dd'T'HH:mm:ss.SSSZ"`)
- Swift: `String` or `Date` (parsed with `MovieList.parseDate()`)

**Arrays:**
- Database: PostgreSQL `TEXT[]` array type
- JSON: Standard JSON arrays `["item1", "item2"]`
- Swift: `[String]` or `[Int]`

**Booleans:**
- Database: `BOOLEAN` type
- Special case - `diary.rewatch`: Stored as `TEXT` ("yes"/"no") for legacy compatibility
- Swift: `Bool` with custom encoding/decoding logic

**UUIDs:**
- Database: `UUID` type
- JSON: String representation
- Swift: `UUID` type with string encoding/decoding

---

## Service Layer Architecture

### Overview

The service layer acts as a **repository pattern** abstracting database operations. All services are **ObservableObject** classes for SwiftUI integration.

### Service Architecture Pattern

```swift
@MainActor  // If UI-binding required
class SupabaseXxxService: ObservableObject {
    static let shared = XxxService()  // Singleton pattern
    
    private let supabase: SupabaseClient
    
    @Published var items: [Item] = []  // Observed state
    @Published var isLoading = false
    @Published var error: Error?
    
    // CRUD Operations
    nonisolated func getItems() async throws -> [Item]
    nonisolated func createItem() async throws -> Item
    nonisolated func updateItem() async throws -> Item
    nonisolated func deleteItem() async throws
    
    // Batch Operations
    nonisolated func batchUpdate() async throws
}
```

### Service Inventory

| Service | Purpose | Key Operations |
|---------|---------|----------------|
| **SupabaseMovieService** | Movie diary CRUD | `getMovies()`, `addMovie()`, `updateMovie()`, `deleteMovie()`, `toggleMovieFavorite()` |
| **SupabaseAlbumService** | Album tracking | `getAlbums()`, `addAlbum()`, `markAsListened()`, `refreshAlbumMetadata()` |
| **SupabaseTelevisionService** | TV show progress | `getShows()`, `updateProgress()`, `toggleFavorite()` |
| **SupabaseListService** | Custom lists management | `createList()`, `addMovieToList()`, `reorderItems()`, `pinList()` |
| **SupabaseWatchlistService** | Watchlist operations | `getWatchlist()`, `addToWatchlist()`, `removeFromWatchlist()` |
| **SupabaseStatisticsService** | Analytics queries | `getDashboardStats()`, `getRatingDistribution()`, `getStreakStats()` |
| **SupabaseProfileService** | User profile management | `getProfile()`, `updateProfile()`, `updateBackdrop()` |
| **TMDBService** | TMDB API integration | `searchMovies()`, `getMovieDetails()`, `searchTV()` |
| **SpotifyService** | Spotify API integration | `searchAlbums()`, `getAlbumDetails()`, `authenticate()` |
| **StreamingService** | Streaming availability | `getStreamingOptions()` |

### Example: SupabaseMovieService

**Key Methods:**

```swift
// Get all movies with filtering
nonisolated func getMovies(
    searchQuery: String? = nil,
    sortBy: MovieSortField = .watchDate,
    ascending: Bool = false,
    limit: Int = 3000,
    offset: Int = 0
) async throws -> [Movie] {
    var query = supabase.from("diary").select()
    
    if let search = searchQuery {
        query = query.or("title.ilike.%\(search)%,director.ilike.%\(search)%")
    }
    
    query = query
        .order(sortBy.supabaseColumn, ascending: ascending)
        .limit(limit)
        .range(from: offset, to: offset + limit - 1)
    
    let response = try await query.execute()
    return try JSONDecoder().decode([Movie].self, from: response.data)
}

// Add a movie
nonisolated func addMovie(_ movieData: AddMovieRequest) async throws -> Movie {
    let response = try await supabase
        .from("diary")
        .insert(movieData)
        .select()
        .execute()
    
    let movies = try JSONDecoder().decode([Movie].self, from: response.data)
    
    // Auto-remove from watchlist after watching
    if let tmdbId = movies.first?.tmdb_id {
        try? await SupabaseWatchlistService.shared.removeFromWatchlist(tmdbId: tmdbId)
    }
    
    return movies.first!
}

// Toggle favorite status
nonisolated func toggleMovieFavorite(movieId: Int) async throws -> Movie {
    // Fetch current state
    let currentMovie: Movie = try await supabase
        .from("diary")
        .select()
        .eq("id", value: movieId)
        .single()
        .execute()
        .value
    
    let newFavoriteState = !(currentMovie.favorited ?? false)
    
    // Update
    let response: Movie = try await supabase
        .from("diary")
        .update(["favorited": newFavoriteState])
        .eq("id", value: movieId)
        .select()
        .single()
        .execute()
        .value
    
    return response
}
```

### Request/Response Models

**Add Movie Request:**

```swift
struct AddMovieRequest: Codable {
    let title: String
    let release_year: Int?
    let release_date: String?
    let rating: Double?
    let ratings100: Double?              // Detailed rating
    let reviews: String?                 // Review text
    let tags: String?
    let watched_date: String?
    let rewatch: String?                 // "yes" or "no"
    let tmdb_id: Int?
    let overview: String?
    let poster_url: String?
    let backdrop_path: String?
    let director: String?
    let runtime: Int?
    let genres: [String]?
    // ... additional TMDB fields
}
```

**Update Movie Request:**

```swift
struct UpdateMovieRequest: Codable {
    // All fields optional for partial updates
    let title: String?
    let rating: Double?
    let ratings100: Double?
    let reviews: String?
    let tags: String?
    let watched_date: String?
    // ... etc
}
```

---

## API Layer

### Node.js/Express Backend

**Location:** `/reelay2/Resources/server.js`

**Purpose:** 
- Middleware caching layer (Redis)
- Complex aggregation queries
- Streaming availability integration
- Performance optimization for statistics

### API Endpoints

#### Movies

| Method | Endpoint | Description | Cache |
|--------|----------|-------------|-------|
| GET | `/api/movies` | Get all diary entries | 10min |
| POST | `/api/movies` | Add movie to diary | No |
| PUT | `/api/movies/:id` | Update movie | No |
| DELETE | `/api/movies/:id` | Delete movie | No |
| GET | `/api/movies/check?tmdb_id=X` | Check if movie exists | No |
| GET | `/api/movies/by-tmdb?tmdb_id=X` | Get all instances of TMDB ID | No |
| PUT | `/api/movies/tmdb/:tmdbId/poster` | Update poster for all instances | No |
| PUT | `/api/movies/tmdb/:tmdbId/backdrop` | Update backdrop for all instances | No |
| GET | `/api/movies/backdrop-selection` | Get movies for backdrop picker | No |
| GET | `/api/movies/rating-range?min=X&max=Y` | Filter by rating | No |
| GET | `/api/movies/watched-counts?tmdb_ids=1,2,3` | Batch count queries | No |
| GET | `/api/movies/watched-status?tmdb_ids=1,2,3` | Batch watched check | No |

#### Statistics

| Method | Endpoint | Description | Cache |
|--------|----------|-------------|-------|
| GET | `/api/statistics/:userId` | Dashboard summary stats | 5min |
| GET | `/api/statistics/:userId/rating-distribution` | Rating breakdown | 5min |
| GET | `/api/statistics/:userId/rating-stats` | Avg/median/mode ratings | 5min |
| GET | `/api/statistics/:userId/films-per-year` | Yearly breakdown | 5min |
| GET | `/api/statistics/:userId/films-per-month?year=2024` | Monthly breakdown | 5min |
| GET | `/api/statistics/:userId/genre-stats?limit=10` | Top genres | 5min |
| GET | `/api/statistics/:userId/director-stats?limit=10` | Top directors | 5min |

#### Lists

| Method | Endpoint | Description | Cache |
|--------|----------|-------------|-------|
| GET | `/api/lists/:userId` | Get user's lists | 5min |
| POST | `/api/lists` | Create list | No |
| PUT | `/api/lists/:listId` | Update list metadata | No |
| DELETE | `/api/lists/:listId` | Delete list (cascade items) | No |
| PUT | `/api/lists/:listId/pin` | Pin/unpin list | No |
| GET | `/api/lists/:listId/items` | Get list items | 5min |
| POST | `/api/lists/:listId/items` | Add item to list | No |
| DELETE | `/api/lists/:listId/items/:itemId` | Remove item | No |
| PUT | `/api/lists/:listId/reorder` | Batch reorder items | No |

#### Watchlist

| Method | Endpoint | Description | Cache |
|--------|----------|-------------|-------|
| GET | `/api/watchlist/:userId` | Get watchlist | 5min |
| POST | `/api/watchlist` | Add to watchlist | No |
| DELETE | `/api/watchlist/:userId/tmdb/:tmdbId` | Remove by TMDB ID | No |
| DELETE | `/api/watchlist/item/:itemId` | Remove by item ID | No |
| GET | `/api/watchlist/:userId/check?tmdb_id=X` | Check if in watchlist | No |

#### Streaming

| Method | Endpoint | Description | Cache |
|--------|----------|-------------|-------|
| GET | `/api/streaming/:type/:tmdbId?country=us` | Get streaming options | 24h |
| GET | `/api/streaming/services/:country` | Get available services | 24h |
| DELETE | `/api/streaming/cache/:type/:tmdbId` | Clear streaming cache | No |

#### Profile

| Method | Endpoint | Description | Cache |
|--------|----------|-------------|-------|
| GET | `/api/profile/:userId` | Get user profile | 5min |
| PUT | `/api/profile/:userId` | Update profile | No |

#### Cache Management

| Method | Endpoint | Description |
|--------|----------|-------------|
| DELETE | `/api/cache/:pattern` | Clear cache by pattern |

### Authentication Middleware

**Method:** Better Auth session token validation

```javascript
const authenticateUser = async (req, res, next) => {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({ error: 'No valid authorization header' });
    }
    
    const token = authHeader.substring(7);
    
    // Verify with Better Auth server
    const response = await fetch(`${BETTER_AUTH_URL}/api/auth/get-session`, {
        method: 'GET',
        headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json',
        },
    });
    
    if (!response.ok) {
        return res.status(401).json({ error: 'Invalid or expired token' });
    }
    
    const sessionResult = await response.json();
    req.user = {
        id: sessionResult.user.id,
        email: sessionResult.user.email,
        name: sessionResult.user.name,
    };
    
    next();
};
```

---

## Caching Strategy

### Redis Cache Implementation

**Connection:**
```javascript
const redisClient = redis.createClient({
    url: process.env.REDIS_URL
});
```

### Cache Middleware

```javascript
const cache = (duration = 300) => {  // Default 5min TTL
    return async (req, res, next) => {
        const key = req.originalUrl;
        const cached = await redisClient.get(key);
        
        if (cached) {
            return res.json(JSON.parse(cached));
        }
        
        // Override res.json to cache response
        res.sendResponse = res.json;
        res.json = (body) => {
            redisClient.setEx(key, duration, JSON.stringify(body));
            res.sendResponse(body);
        };
        
        next();
    };
};
```

### Cache TTL Strategy

| Data Type | TTL | Reasoning |
|-----------|-----|-----------|
| Movies/Lists | 10min (600s) | Frequently mutated, needs freshness |
| Statistics | 5min (300s) | Expensive queries, tolerate slight staleness |
| Streaming Data | 24h (86400s) | External API, slow to change, rate-limited |
| TMDB Metadata | Handled by iOS app | Cached in UserDefaults/local storage |

### Cache Invalidation

**Pattern-based deletion:**

```javascript
// Clear all statistics for a user
DELETE /api/cache//api/statistics/:userId*

// Clear specific list cache
DELETE /api/cache//api/lists/:listId*
```

**Automatic invalidation** happens on:
- Movie additions/updates/deletions â†’ Clear `/api/movies*` and `/api/statistics*`
- List mutations â†’ Clear `/api/lists/:listId*`

---

## External Integrations

### 1. TMDB API (The Movie Database)

**Purpose:** Movie and TV show metadata

**Authentication:** API Key (`Config.TMDB_API_KEY`)

**Base URL:** `https://api.themoviedb.org/3`

**Key Endpoints Used:**

```
GET /search/movie?query={query}&api_key={key}
GET /movie/{tmdb_id}?api_key={key}&append_to_response=credits,videos,images
GET /search/tv?query={query}&api_key={key}
GET /tv/{tmdb_id}?api_key={key}&append_to_response=credits
GET /movie/{tmdb_id}/images?api_key={key}
```

**Integration Pattern:**

```swift
class TMDBService {
    func searchMovies(query: String) async throws -> [TMDBMovie] {
        let url = "https://api.themoviedb.org/3/search/movie"
        var components = URLComponents(string: url)!
        components.queryItems = [
            URLQueryItem(name: "query", value: query),
            URLQueryItem(name: "api_key", value: Config.TMDB_API_KEY)
        ]
        
        let (data, _) = try await URLSession.shared.data(from: components.url!)
        let response = try JSONDecoder().decode(TMDBSearchResponse.self, from: data)
        return response.results
    }
}
```

**Image URLs:**

TMDB provides relative paths, which must be prefixed:

```swift
// Poster: https://image.tmdb.org/t/p/w500{poster_path}
// Backdrop: https://image.tmdb.org/t/p/w1280{backdrop_path}

var posterURL: URL? {
    guard let path = poster_url else { return nil }
    if path.hasPrefix("http") { return URL(string: path) }
    if path.hasPrefix("/") {
        return URL(string: "https://image.tmdb.org/t/p/w500\(path)")
    }
    return URL(string: path)
}
```

### 2. Spotify Web API

**Purpose:** Album metadata and track listings

**Authentication:** OAuth 2.0 Client Credentials Flow

**Credentials:**
- Client ID: `Config.SPOTIFY_CLIENT_ID`
- Client Secret: `Config.SPOTIFY_CLIENT_SECRET`

**Base URL:** `https://api.spotify.com/v1`

**Authentication Flow:**

```swift
func authenticate() async throws {
    let credentials = "\(clientId):\(clientSecret)"
    let base64Credentials = credentials.data(using: .utf8)!.base64EncodedString()
    
    var request = URLRequest(url: URL(string: "https://accounts.spotify.com/api/token")!)
    request.httpMethod = "POST"
    request.setValue("Basic \(base64Credentials)", forHTTPHeaderField: "Authorization")
    request.setValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type")
    request.httpBody = "grant_type=client_credentials".data(using: .utf8)
    
    let (data, _) = try await URLSession.shared.data(for: request)
    let response = try JSONDecoder().decode(SpotifyTokenResponse.self, from: data)
    
    accessToken = response.access_token  // Store for subsequent requests
}
```

**Key Endpoints:**

```
GET /search?q={query}&type=album
GET /albums/{spotify_id}
GET /albums/{spotify_id}/tracks
```

### 3. Streaming Availability API (RapidAPI)

**Purpose:** Check which streaming services have specific content

**Authentication:** RapidAPI Key

**Integration:**

```javascript
const streamingClient = new streamingAvailability.Client(
    new streamingAvailability.Configuration({
        apiKey: RAPID_API_KEY
    })
);

// Get streaming options
const showData = await streamingClient.showsApi.getShow({
    id: tmdbId.toString(),
    country: 'us'
});

// Returns: { streamingOptions: { netflix: {...}, hulu: {...} } }
```

**Caching:** 24-hour TTL to minimize API calls

---

## Authentication & Security

### Authentication Flow

**Provider:** Google OAuth via Better Auth

**Session Management:** Better Auth handles session tokens (32-character strings)

**Flow:**

```
1. User initiates Google Sign-In in iOS app
2. Better Auth redirects to Google OAuth
3. Google returns authorization code
4. Better Auth exchanges for access token
5. Better Auth creates session and returns session token
6. iOS app stores session token in Keychain
7. All API requests include: Authorization: Bearer {session_token}
```

### Row-Level Security (RLS)

**Supabase RLS Policies** enforce data isolation:

**Example - Albums Table:**

```sql
ALTER TABLE albums ENABLE ROW LEVEL SECURITY;

-- Users see only their own albums
CREATE POLICY "Users can view their own albums" ON albums
    FOR SELECT USING (auth.uid() = user_id);

-- Users can insert only with their own user_id
CREATE POLICY "Users can insert their own albums" ON albums
    FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Users can update only their own albums
CREATE POLICY "Users can update their own albums" ON albums
    FOR UPDATE USING (auth.uid() = user_id);

-- Users can delete only their own albums
CREATE POLICY "Users can delete their own albums" ON albums
    FOR DELETE USING (auth.uid() = user_id);
```

**Security Principle:** 
- Authenticated users: Full CRUD on their own data
- Anonymous users: **No access** (all tables have `REVOKE ALL FROM anon`)

### API Security

**Node.js Server Authentication:**

Every endpoint (except `/health`) is protected by `authenticateUser` middleware which:
1. Validates Bearer token with Better Auth server
2. Attaches `req.user` object with user ID
3. Uses user ID in all database queries

**Example:**

```javascript
app.get('/api/movies', authenticateUser, async (req, res) => {
    const userId = req.user.id;  // From session
    const result = await pool.query(
        'SELECT * FROM diary WHERE user_id = $1',
        [userId]
    );
    res.json(result.rows);
});
```

---

## Data Flow & Processing

### 1. Adding a Movie (Complete Flow)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User Action  â”‚ Searches for movie "Inception"
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ AddMoviesViewâ”‚ User taps search
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TMDBService  â”‚ GET /search/movie?query=Inception
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼ Returns [TMDBMovie] array
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ AddMoviesViewâ”‚ User selects movie, fills out form
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TMDBService  â”‚ GET /movie/{tmdb_id} (fetch full details)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ AddMoviesViewâ”‚ Constructs AddMovieRequest with:
â”‚              â”‚ - TMDB metadata (title, year, genres, etc.)
â”‚              â”‚ - User data (rating, tags, watch_date)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SupabaseMovieServiceâ”‚ addMovie(AddMovieRequest)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Supabase API â”‚ INSERT INTO diary VALUES (...)
â”‚ (PostgreSQL) â”‚ RETURNING *
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼ Returns Movie object
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SupabaseMovieServiceâ”‚ Check if movie.tmdb_id is in watchlist
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚SupabaseWatchlistServiceâ”‚ removeFromWatchlist(tmdb_id)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Supabase API â”‚ DELETE FROM watchlist WHERE tmdb_id = X
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MoviesView   â”‚ SwiftUI observes @Published movies array
â”‚              â”‚ UI updates automatically
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. Creating a Custom List with Items

```
User creates "Best of 2024" list
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚SupabaseListServiceâ”‚ createList(name: "Best of 2024", ranked: true)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼ INSERT INTO lists
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PostgreSQL   â”‚ Returns MovieList with UUID
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
User adds "Dune Part Two" to list
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚SupabaseListServiceâ”‚ addMovieToList(tmdbId: 693134, listId: UUID)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”‚  Fetch TMDB metadata if not in diary
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TMDBService  â”‚ GET /movie/693134
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PostgreSQL   â”‚ INSERT INTO list_items (list_id, tmdb_id, movie_title, ...)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PostgreSQL   â”‚ UPDATE lists SET item_count = item_count + 1
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ListDetailsViewâ”‚ SwiftUI updates automatically
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3. Statistics Calculation (Dashboard)

```
User opens Statistics tab
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚SupabaseStatisticsServiceâ”‚ getDashboardStats()
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Node.js API  â”‚ GET /api/statistics/:userId
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼ Check Redis cache
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Redis        â”‚ Key: /api/statistics/{userId}
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€ Cache HIT: Return cached JSON (5min TTL)
       â”‚
       â””â”€ Cache MISS:
              â”‚
              â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚ PostgreSQL   â”‚ Call get_dashboard_stats() function
       â”‚ (Function)   â”‚ SELECT COUNT(*), AVG(rating), ...
       â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼ Complex aggregations
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚ Result:      â”‚ {
       â”‚              â”‚   total_films: 523,
       â”‚              â”‚   unique_films: 489,
       â”‚              â”‚   average_rating: 3.8,
       â”‚              â”‚   ...
       â”‚              â”‚ }
       â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼ Cache result for 5min
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚ Redis        â”‚ SETEX key 300 value
       â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼
       Return JSON to client
```

### 4. Streaming Availability Check

```
User views movie details for "Dune Part Two"
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ StreamingService â”‚ getStreamingOptions(tmdbId: 693134, type: "movie")
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Node.js API  â”‚ GET /api/streaming/movie/693134?country=us
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼ Check Redis cache
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Redis        â”‚ Key: streaming:movie:693134:us
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€ Cache HIT (24h TTL): Return cached data
       â”‚
       â””â”€ Cache MISS:
              â”‚
              â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚ RapidAPI            â”‚ GET streaming availability
       â”‚ (Streaming Avail.)  â”‚ for TMDB ID 693134
       â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚ Result:      â”‚ {
       â”‚              â”‚   streamingOptions: {
       â”‚              â”‚     us: {
       â”‚              â”‚       netflix: { ... },
       â”‚              â”‚       hbo: { link: "...", quality: "4K" }
       â”‚              â”‚     }
       â”‚              â”‚   }
       â”‚              â”‚ }
       â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼ Cache for 24h
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚ Redis        â”‚ SETEX key 86400 value
       â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼
       Display streaming options in MovieDetailsView
```

### 5. Album Addition with Spotify Metadata

```
User searches for "In Rainbows" by Radiohead
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SpotifyService   â”‚ authenticate() â†’ Get OAuth token
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SpotifyService   â”‚ searchAlbums(query: "In Rainbows Radiohead")
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼ GET /search?q=...&type=album
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Spotify API  â”‚ Returns [SpotifyAlbum] array
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
User selects correct album
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SpotifyService   â”‚ getAlbumDetails(albumId: "...")
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼ GET /albums/{id} and /albums/{id}/tracks
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Spotify API  â”‚ Returns full album + tracks
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ AddAlbumsView    â”‚ Constructs AddAlbumRequest
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚SupabaseAlbumServiceâ”‚ addAlbum(AddAlbumRequest)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PostgreSQL   â”‚ INSERT INTO albums (...) RETURNING *
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼ Returns Album with id
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚SupabaseAlbumServiceâ”‚ addTracksToAlbum(albumId, tracks)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PostgreSQL   â”‚ INSERT INTO album_tracks (album_id, ...)
â”‚              â”‚ Multiple rows (one per track)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
Album now appears in AlbumsView with full tracklist
```

---

## Performance Optimizations

### Database Indexes

All high-traffic columns have indexes:

```sql
-- Diary table
CREATE INDEX idx_diary_tmdb_id ON diary(tmdb_id);
CREATE INDEX idx_diary_watched_date ON diary(watched_date);
CREATE INDEX idx_diary_rating ON diary(rating);
CREATE INDEX idx_diary_title_lower ON diary(LOWER(title));

-- Lists
CREATE INDEX idx_lists_user_id ON lists(user_id);
CREATE INDEX idx_list_items_list_id ON list_items(list_id);
CREATE INDEX idx_list_items_sort_order ON list_items(list_id, sort_order);

-- Albums
CREATE INDEX idx_albums_user_id ON albums(user_id);
CREATE INDEX idx_albums_status ON albums(status);
```

### Query Optimization Patterns

**1. Pagination:**
```swift
query
    .limit(limit)
    .range(from: offset, to: offset + limit - 1)
```

**2. Filtering before sorting:**
```swift
query
    .eq("status", value: "watching")              // Filter first
    .order("updated_at", ascending: false)        // Then sort
```

**3. Batch queries for exists checks:**
```swift
// Instead of N queries checking if movie is watched:
checkWatchedStatusForTmdbIds(tmdbIds: [1, 2, 3, ...])
// Single query: SELECT DISTINCT tmdb_id WHERE tmdb_id = ANY($1)
```

### Caching Layers

1. **Redis (Server-side):** API responses, 5min-24h TTL
2. **SwiftData (Local):** Lists and list items persisted locally
3. **UserDefaults (App):** TMDB search history
4. **Memory (@Published vars):** In-flight data in service singletons

---

## Data Migration & Versioning

### CSV Import (Legacy Data)

**Purpose:** Import historical data from spreadsheets

**Implementation:** `CSVImporter.swift`

```swift
class CSVImporter {
    func importMovies(from csvURL: URL) async throws {
        let csv = try String(contentsOf: csvURL)
        let rows = csv.components(separatedBy: "\n")
        
        for row in rows.dropFirst() {  // Skip header
            let columns = row.components(separatedBy: ",")
            
            let movieRequest = AddMovieRequest(
                title: columns[0],
                watched_date: parseDate(columns[1]),
                rating: Double(columns[2]),
                tags: columns[3],
                // ... map all columns
            )
            
            try await SupabaseMovieService.shared.addMovie(movieRequest)
        }
    }
}
```

### Schema Versioning

**Approach:** PostgreSQL migrations via Supabase dashboard

**Example Migration:**

```sql
-- Add favorited column to diary table
ALTER TABLE diary ADD COLUMN favorited BOOLEAN DEFAULT FALSE;

-- Backfill existing data
UPDATE diary SET favorited = FALSE WHERE favorited IS NULL;

-- Add index
CREATE INDEX idx_diary_favorited ON diary(favorited) WHERE favorited = TRUE;
```

### Data Export

**Not yet implemented**, but would follow pattern:

```swift
func exportDiary() async throws -> URL {
    let movies = try await SupabaseMovieService.shared.getMovies(limit: 10000)
    
    var csv = "Title,Date,Rating,Review\n"
    for movie in movies {
        csv += "\(movie.title),\(movie.watch_date ?? ""),\(movie.rating ?? 0),\"\(movie.review ?? "")\"\n"
    }
    
    let fileURL = FileManager.default.temporaryDirectory.appendingPathComponent("diary_export.csv")
    try csv.write(to: fileURL, atomically: true, encoding: .utf8)
    
    return fileURL
}
```

---

## Development Recommendations for Rebuilding Backend

### 1. Database Setup

**Required Tables (in order):**
1. `users` (extends Supabase auth.users)
2. `diary` (movies)
3. `albums` + `album_tracks`
4. `television`
5. `lists` + `list_items`
6. `watchlist`
7. `user_profiles`
8. `month_descriptors` (optional)

**Critical Indexes:**
- ALL foreign keys
- `user_id` on every user-owned table
- `tmdb_id`, `spotify_id` where applicable
- Date columns for sorting (`watched_date`, `created_at`)
- Text search columns with LOWER() index

### 2. RLS Policies (Security-Critical)

For every table:
```sql
ALTER TABLE {table} ENABLE ROW LEVEL SECURITY;

CREATE POLICY "select_policy" ON {table}
    FOR SELECT USING (auth.uid() = user_id);
    
CREATE POLICY "insert_policy" ON {table}
    FOR INSERT WITH CHECK (auth.uid() = user_id);
    
CREATE POLICY "update_policy" ON {table}
    FOR UPDATE USING (auth.uid() = user_id);
    
CREATE POLICY "delete_policy" ON {table}
    FOR DELETE USING (auth.uid() = user_id);

REVOKE ALL ON {table} FROM anon;
GRANT ALL ON {table} TO authenticated;
```

### 3. API Server Setup

**Environment Variables:**
```bash
DATABASE_URL=postgresql://user:pass@host:port/db
REDIS_URL=redis://host:port
BETTER_AUTH_URL=https://auth.yourapp.com
BETTER_AUTH_SECRET=xxx
RAPID_API_KEY=xxx
TMDB_API_KEY=xxx
PORT=3000
```

**Dependencies:**
```json
{
  "express": "^4.18.0",
  "pg": "^8.11.0",
  "redis": "^4.6.0",
  "cors": "^2.8.5",
  "streaming-availability": "^4.0.0"
}
```

### 4. Suggested Improvements for New Backend

**A. Use Database Functions for Complex Stats**

Instead of:
```javascript
// Multiple queries in Node.js
const totalMovies = await pool.query('SELECT COUNT(*) FROM diary');
const avgRating = await pool.query('SELECT AVG(rating) FROM diary');
// ... combine results
```

Use:
```sql
CREATE OR REPLACE FUNCTION get_dashboard_stats(p_user_id UUID)
RETURNS JSON AS $$
DECLARE
    result JSON;
BEGIN
    SELECT json_build_object(
        'total_films', COUNT(*),
        'unique_films', COUNT(DISTINCT tmdb_id),
        'average_rating', AVG(rating),
        'films_this_year', COUNT(*) FILTER (WHERE EXTRACT(YEAR FROM watched_date) = EXTRACT(YEAR FROM CURRENT_DATE))
    )
    INTO result
    FROM diary
    WHERE user_id = p_user_id;
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;
```

**B. Use Database Triggers for Auto-Updates**

```sql
-- Auto-update list item counts
CREATE OR REPLACE FUNCTION update_list_item_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE lists SET item_count = item_count + 1 WHERE id = NEW.list_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE lists SET item_count = item_count - 1 WHERE id = OLD.list_id;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_list_count
AFTER INSERT OR DELETE ON list_items
FOR EACH ROW EXECUTE FUNCTION update_list_item_count();
```

**C. Add Full-Text Search**

```sql
-- Add tsvector column
ALTER TABLE diary ADD COLUMN search_vector tsvector;

-- Update trigger
CREATE FUNCTION diary_search_trigger() RETURNS trigger AS $$
BEGIN
    NEW.search_vector := to_tsvector('english', 
        COALESCE(NEW.title, '') || ' ' || 
        COALESCE(NEW.director, '') || ' ' ||
        COALESCE(NEW.overview, '')
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_search_vector
BEFORE INSERT OR UPDATE ON diary
FOR EACH ROW EXECUTE FUNCTION diary_search_trigger();

-- Search query
SELECT * FROM diary 
WHERE search_vector @@ to_tsquery('english', 'nolan & batman');
```

**D. Implement GraphQL Instead of REST**

Consider using Supabase's PostgREST auto-generated API or implement GraphQL for:
- Nested queries (lists with items in one request)
- Field selection (reduce over-fetching)
- Better TypeScript integration

---

## Conclusion

This document provides a comprehensive blueprint for understanding and rebuilding Reelay2's backend architecture. The system is designed with:

- **Separation of concerns:** UI layer (Swift) â†” Service layer (Swift) â†” API layer (Node.js) â†” Database (PostgreSQL)
- **Performance:** Multi-layer caching, indexed queries, batch operations
- **Security:** RLS policies, authenticated-only endpoints, OAuth integration
- **Scalability:** Pagination, efficient queries, external API rate limiting

Key principles to maintain:
1. **User data isolation** via RLS policies
2. **Idempotent operations** where possible
3. **Graceful degradation** when external APIs fail
4. **Cache invalidation** on mutations
5. **Offline-first** design with local SwiftData persistence

For questions or clarifications, refer to the codebase or reach out to the development team.
